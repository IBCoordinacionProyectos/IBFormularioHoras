{"ast":null,"code":"import { CalendarDay } from \"../classes/index.js\";\nimport { dateMatchModifiers } from \"../utils/dateMatchModifiers.js\";\nimport { getFocusableDate } from \"./getFocusableDate.js\";\n/**\n * Determines the next focusable day in the calendar.\n *\n * This function recursively calculates the next focusable day based on the\n * movement direction and modifiers applied to the days.\n *\n * @param moveBy The unit of movement (e.g., \"day\", \"week\").\n * @param moveDir The direction of movement (\"before\" or \"after\").\n * @param refDay The currently focused day.\n * @param calendarStartMonth The earliest month the user can navigate to.\n * @param calendarEndMonth The latest month the user can navigate to.\n * @param props The DayPicker props, including modifiers and configuration\n *   options.\n * @param dateLib The date library to use for date manipulation.\n * @param attempt The current recursion attempt (used to limit recursion depth).\n * @returns The next focusable day, or `undefined` if no focusable day is found.\n */\nexport function getNextFocus(moveBy, moveDir, refDay, calendarStartMonth, calendarEndMonth, props, dateLib) {\n  let attempt = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n  if (attempt > 365) {\n    // Limit the recursion to 365 attempts\n    return undefined;\n  }\n  const focusableDate = getFocusableDate(moveBy, moveDir, refDay.date, calendarStartMonth, calendarEndMonth, props, dateLib);\n  const isDisabled = Boolean(props.disabled && dateMatchModifiers(focusableDate, props.disabled, dateLib));\n  const isHidden = Boolean(props.hidden && dateMatchModifiers(focusableDate, props.hidden, dateLib));\n  const targetMonth = focusableDate;\n  const focusDay = new CalendarDay(focusableDate, targetMonth, dateLib);\n  if (!isDisabled && !isHidden) {\n    return focusDay;\n  }\n  // Recursively attempt to find the next focusable date\n  return getNextFocus(moveBy, moveDir, focusDay, calendarStartMonth, calendarEndMonth, props, dateLib, attempt + 1);\n}","map":{"version":3,"names":["CalendarDay","dateMatchModifiers","getFocusableDate","getNextFocus","moveBy","moveDir","refDay","calendarStartMonth","calendarEndMonth","props","dateLib","attempt","arguments","length","undefined","focusableDate","date","isDisabled","Boolean","disabled","isHidden","hidden","targetMonth","focusDay"],"sources":["D:/formulario de horas/FormularioHoras Version 1/frontend/node_modules/react-day-picker/dist/esm/helpers/getNextFocus.js"],"sourcesContent":["import { CalendarDay } from \"../classes/index.js\";\nimport { dateMatchModifiers } from \"../utils/dateMatchModifiers.js\";\nimport { getFocusableDate } from \"./getFocusableDate.js\";\n/**\n * Determines the next focusable day in the calendar.\n *\n * This function recursively calculates the next focusable day based on the\n * movement direction and modifiers applied to the days.\n *\n * @param moveBy The unit of movement (e.g., \"day\", \"week\").\n * @param moveDir The direction of movement (\"before\" or \"after\").\n * @param refDay The currently focused day.\n * @param calendarStartMonth The earliest month the user can navigate to.\n * @param calendarEndMonth The latest month the user can navigate to.\n * @param props The DayPicker props, including modifiers and configuration\n *   options.\n * @param dateLib The date library to use for date manipulation.\n * @param attempt The current recursion attempt (used to limit recursion depth).\n * @returns The next focusable day, or `undefined` if no focusable day is found.\n */\nexport function getNextFocus(moveBy, moveDir, refDay, calendarStartMonth, calendarEndMonth, props, dateLib, attempt = 0) {\n    if (attempt > 365) {\n        // Limit the recursion to 365 attempts\n        return undefined;\n    }\n    const focusableDate = getFocusableDate(moveBy, moveDir, refDay.date, calendarStartMonth, calendarEndMonth, props, dateLib);\n    const isDisabled = Boolean(props.disabled &&\n        dateMatchModifiers(focusableDate, props.disabled, dateLib));\n    const isHidden = Boolean(props.hidden && dateMatchModifiers(focusableDate, props.hidden, dateLib));\n    const targetMonth = focusableDate;\n    const focusDay = new CalendarDay(focusableDate, targetMonth, dateLib);\n    if (!isDisabled && !isHidden) {\n        return focusDay;\n    }\n    // Recursively attempt to find the next focusable date\n    return getNextFocus(moveBy, moveDir, focusDay, calendarStartMonth, calendarEndMonth, props, dateLib, attempt + 1);\n}\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,qBAAqB;AACjD,SAASC,kBAAkB,QAAQ,gCAAgC;AACnE,SAASC,gBAAgB,QAAQ,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,YAAYA,CAACC,MAAM,EAAEC,OAAO,EAAEC,MAAM,EAAEC,kBAAkB,EAAEC,gBAAgB,EAAEC,KAAK,EAAEC,OAAO,EAAe;EAAA,IAAbC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EACnH,IAAID,OAAO,GAAG,GAAG,EAAE;IACf;IACA,OAAOG,SAAS;EACpB;EACA,MAAMC,aAAa,GAAGb,gBAAgB,CAACE,MAAM,EAAEC,OAAO,EAAEC,MAAM,CAACU,IAAI,EAAET,kBAAkB,EAAEC,gBAAgB,EAAEC,KAAK,EAAEC,OAAO,CAAC;EAC1H,MAAMO,UAAU,GAAGC,OAAO,CAACT,KAAK,CAACU,QAAQ,IACrClB,kBAAkB,CAACc,aAAa,EAAEN,KAAK,CAACU,QAAQ,EAAET,OAAO,CAAC,CAAC;EAC/D,MAAMU,QAAQ,GAAGF,OAAO,CAACT,KAAK,CAACY,MAAM,IAAIpB,kBAAkB,CAACc,aAAa,EAAEN,KAAK,CAACY,MAAM,EAAEX,OAAO,CAAC,CAAC;EAClG,MAAMY,WAAW,GAAGP,aAAa;EACjC,MAAMQ,QAAQ,GAAG,IAAIvB,WAAW,CAACe,aAAa,EAAEO,WAAW,EAAEZ,OAAO,CAAC;EACrE,IAAI,CAACO,UAAU,IAAI,CAACG,QAAQ,EAAE;IAC1B,OAAOG,QAAQ;EACnB;EACA;EACA,OAAOpB,YAAY,CAACC,MAAM,EAAEC,OAAO,EAAEkB,QAAQ,EAAEhB,kBAAkB,EAAEC,gBAAgB,EAAEC,KAAK,EAAEC,OAAO,EAAEC,OAAO,GAAG,CAAC,CAAC;AACrH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}