{"ast":null,"code":"import { tzOffset } from \"../tzOffset/index.js\";\nexport class TZDateMini extends Date {\n  //#region static\n\n  constructor() {\n    super();\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (args.length > 1 && typeof args[args.length - 1] === \"string\") {\n      this.timeZone = args.pop();\n    }\n    this.internal = new Date();\n    if (isNaN(tzOffset(this.timeZone, this))) {\n      this.setTime(NaN);\n    } else {\n      if (!args.length) {\n        this.setTime(Date.now());\n      } else if (typeof args[0] === \"number\" && (args.length === 1 || args.length === 2 && typeof args[1] !== \"number\")) {\n        this.setTime(args[0]);\n      } else if (typeof args[0] === \"string\") {\n        this.setTime(+new Date(args[0]));\n      } else if (args[0] instanceof Date) {\n        this.setTime(+args[0]);\n      } else {\n        this.setTime(+new Date(...args));\n        adjustToSystemTZ(this, NaN);\n        syncToInternal(this);\n      }\n    }\n  }\n  static tz(tz) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    return args.length ? new TZDateMini(...args, tz) : new TZDateMini(Date.now(), tz);\n  }\n\n  //#endregion\n\n  //#region time zone\n\n  withTimeZone(timeZone) {\n    return new TZDateMini(+this, timeZone);\n  }\n  getTimezoneOffset() {\n    const offset = -tzOffset(this.timeZone, this);\n    // Remove the seconds offset\n    // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n    return offset > 0 ? Math.floor(offset) : Math.ceil(offset);\n  }\n\n  //#endregion\n\n  //#region time\n\n  setTime(time) {\n    Date.prototype.setTime.apply(this, arguments);\n    syncToInternal(this);\n    return +this;\n  }\n\n  //#endregion\n\n  //#region date-fns integration\n\n  [Symbol.for(\"constructDateFrom\")](date) {\n    return new TZDateMini(+new Date(date), this.timeZone);\n  }\n\n  //#endregion\n}\n\n// Assign getters and setters\nconst re = /^(get|set)(?!UTC)/;\nObject.getOwnPropertyNames(Date.prototype).forEach(method => {\n  if (!re.test(method)) return;\n  const utcMethod = method.replace(re, \"$1UTC\");\n  // Filter out methods without UTC counterparts\n  if (!TZDateMini.prototype[utcMethod]) return;\n  if (method.startsWith(\"get\")) {\n    // Delegate to internal date's UTC method\n    TZDateMini.prototype[method] = function () {\n      return this.internal[utcMethod]();\n    };\n  } else {\n    // Assign regular setter\n    TZDateMini.prototype[method] = function () {\n      Date.prototype[utcMethod].apply(this.internal, arguments);\n      syncFromInternal(this);\n      return +this;\n    };\n\n    // Assign UTC setter\n    TZDateMini.prototype[utcMethod] = function () {\n      Date.prototype[utcMethod].apply(this, arguments);\n      syncToInternal(this);\n      return +this;\n    };\n  }\n});\n\n/**\n * Function syncs time to internal date, applying the time zone offset.\n *\n * @param {Date} date - Date to sync\n */\nfunction syncToInternal(date) {\n  date.internal.setTime(+date);\n  date.internal.setUTCSeconds(date.internal.getUTCSeconds() - Math.round(-tzOffset(date.timeZone, date) * 60));\n}\n\n/**\n * Function syncs the internal date UTC values to the date. It allows to get\n * accurate timestamp value.\n *\n * @param {Date} date - The date to sync\n */\nfunction syncFromInternal(date) {\n  // First we transpose the internal values\n  Date.prototype.setFullYear.call(date, date.internal.getUTCFullYear(), date.internal.getUTCMonth(), date.internal.getUTCDate());\n  Date.prototype.setHours.call(date, date.internal.getUTCHours(), date.internal.getUTCMinutes(), date.internal.getUTCSeconds(), date.internal.getUTCMilliseconds());\n\n  // Now we have to adjust the date to the system time zone\n  adjustToSystemTZ(date);\n}\n\n/**\n * Function adjusts the date to the system time zone. It uses the time zone\n * differences to calculate the offset and adjust the date.\n *\n * @param {Date} date - Date to adjust\n */\nfunction adjustToSystemTZ(date) {\n  // Save the time zone offset before all the adjustments\n  const baseOffset = tzOffset(date.timeZone, date);\n  // Remove the seconds offset\n  // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n  const offset = baseOffset > 0 ? Math.floor(baseOffset) : Math.ceil(baseOffset);\n  //#region System DST adjustment\n\n  // The biggest problem with using the system time zone is that when we create\n  // a date from internal values stored in UTC, the system time zone might end\n  // up on the DST hour:\n  //\n  //   $ TZ=America/New_York node\n  //   > new Date(2020, 2, 8, 1).toString()\n  //   'Sun Mar 08 2020 01:00:00 GMT-0500 (Eastern Standard Time)'\n  //   > new Date(2020, 2, 8, 2).toString()\n  //   'Sun Mar 08 2020 03:00:00 GMT-0400 (Eastern Daylight Time)'\n  //   > new Date(2020, 2, 8, 3).toString()\n  //   'Sun Mar 08 2020 03:00:00 GMT-0400 (Eastern Daylight Time)'\n  //   > new Date(2020, 2, 8, 4).toString()\n  //   'Sun Mar 08 2020 04:00:00 GMT-0400 (Eastern Daylight Time)'\n  //\n  // Here we get the same hour for both 2 and 3, because the system time zone\n  // has DST beginning at 8 March 2020, 2 a.m. and jumps to 3 a.m. So we have\n  // to adjust the internal date to reflect that.\n  //\n  // However we want to adjust only if that's the DST hour the change happenes,\n  // not the hour where DST moves to.\n\n  // We calculate the previous hour to see if the time zone offset has changed\n  // and we have landed on the DST hour.\n  const prevHour = new Date(+date);\n  // We use UTC methods here as we don't want to land on the same hour again\n  // in case of DST.\n  prevHour.setUTCHours(prevHour.getUTCHours() - 1);\n\n  // Calculate if we are on the system DST hour.\n  const systemOffset = -new Date(+date).getTimezoneOffset();\n  const prevHourSystemOffset = -new Date(+prevHour).getTimezoneOffset();\n  const systemDSTChange = systemOffset - prevHourSystemOffset;\n  // Detect the DST shift. System DST change will occur both on\n  const dstShift = Date.prototype.getHours.apply(date) !== date.internal.getUTCHours();\n\n  // Move the internal date when we are on the system DST hour.\n  if (systemDSTChange && dstShift) date.internal.setUTCMinutes(date.internal.getUTCMinutes() + systemDSTChange);\n\n  //#endregion\n\n  //#region System diff adjustment\n\n  // Now we need to adjust the date, since we just applied internal values.\n  // We need to calculate the difference between the system and date time zones\n  // and apply it to the date.\n\n  const offsetDiff = systemOffset - offset;\n  if (offsetDiff) Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetDiff);\n\n  //#endregion\n\n  //#region Seconds System diff adjustment\n\n  const systemDate = new Date(+date);\n  // Set the UTC seconds to 0 to isolate the timezone offset in seconds.\n  systemDate.setUTCSeconds(0);\n  // For negative systemOffset, invert the seconds.\n  const systemSecondsOffset = systemOffset > 0 ? systemDate.getSeconds() : (systemDate.getSeconds() - 60) % 60;\n\n  // Calculate the seconds offset based on the timezone offset.\n  const secondsOffset = Math.round(-(tzOffset(date.timeZone, date) * 60)) % 60;\n  if (secondsOffset || systemSecondsOffset) {\n    date.internal.setUTCSeconds(date.internal.getUTCSeconds() + secondsOffset);\n    Date.prototype.setUTCSeconds.call(date, Date.prototype.getUTCSeconds.call(date) + secondsOffset + systemSecondsOffset);\n  }\n\n  //#endregion\n\n  //#region Post-adjustment DST fix\n\n  const postBaseOffset = tzOffset(date.timeZone, date);\n  // Remove the seconds offset\n  // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n  const postOffset = postBaseOffset > 0 ? Math.floor(postBaseOffset) : Math.ceil(postBaseOffset);\n  const postSystemOffset = -new Date(+date).getTimezoneOffset();\n  const postOffsetDiff = postSystemOffset - postOffset;\n  const offsetChanged = postOffset !== offset;\n  const postDiff = postOffsetDiff - offsetDiff;\n  if (offsetChanged && postDiff) {\n    Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + postDiff);\n\n    // Now we need to check if got offset change during the post-adjustment.\n    // If so, we also need both dates to reflect that.\n\n    const newBaseOffset = tzOffset(date.timeZone, date);\n    // Remove the seconds offset\n    // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n    const newOffset = newBaseOffset > 0 ? Math.floor(newBaseOffset) : Math.ceil(newBaseOffset);\n    const offsetChange = postOffset - newOffset;\n    if (offsetChange) {\n      date.internal.setUTCMinutes(date.internal.getUTCMinutes() + offsetChange);\n      Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetChange);\n    }\n  }\n\n  //#endregion\n}","map":{"version":3,"names":["tzOffset","TZDateMini","Date","constructor","_len","arguments","length","args","Array","_key","timeZone","pop","internal","isNaN","setTime","NaN","now","adjustToSystemTZ","syncToInternal","tz","_len2","_key2","withTimeZone","getTimezoneOffset","offset","Math","floor","ceil","time","prototype","apply","Symbol","for","date","re","Object","getOwnPropertyNames","forEach","method","test","utcMethod","replace","startsWith","syncFromInternal","setUTCSeconds","getUTCSeconds","round","setFullYear","call","getUTCFullYear","getUTCMonth","getUTCDate","setHours","getUTCHours","getUTCMinutes","getUTCMilliseconds","baseOffset","prevHour","setUTCHours","systemOffset","prevHourSystemOffset","systemDSTChange","dstShift","getHours","setUTCMinutes","offsetDiff","systemDate","systemSecondsOffset","getSeconds","secondsOffset","postBaseOffset","postOffset","postSystemOffset","postOffsetDiff","offsetChanged","postDiff","newBaseOffset","newOffset","offsetChange"],"sources":["D:/formulario de horas/FormularioHoras Version 1/frontend/node_modules/@date-fns/tz/date/mini.js"],"sourcesContent":["import { tzOffset } from \"../tzOffset/index.js\";\nexport class TZDateMini extends Date {\n  //#region static\n\n  constructor(...args) {\n    super();\n    if (args.length > 1 && typeof args[args.length - 1] === \"string\") {\n      this.timeZone = args.pop();\n    }\n    this.internal = new Date();\n    if (isNaN(tzOffset(this.timeZone, this))) {\n      this.setTime(NaN);\n    } else {\n      if (!args.length) {\n        this.setTime(Date.now());\n      } else if (typeof args[0] === \"number\" && (args.length === 1 || args.length === 2 && typeof args[1] !== \"number\")) {\n        this.setTime(args[0]);\n      } else if (typeof args[0] === \"string\") {\n        this.setTime(+new Date(args[0]));\n      } else if (args[0] instanceof Date) {\n        this.setTime(+args[0]);\n      } else {\n        this.setTime(+new Date(...args));\n        adjustToSystemTZ(this, NaN);\n        syncToInternal(this);\n      }\n    }\n  }\n  static tz(tz, ...args) {\n    return args.length ? new TZDateMini(...args, tz) : new TZDateMini(Date.now(), tz);\n  }\n\n  //#endregion\n\n  //#region time zone\n\n  withTimeZone(timeZone) {\n    return new TZDateMini(+this, timeZone);\n  }\n  getTimezoneOffset() {\n    const offset = -tzOffset(this.timeZone, this);\n    // Remove the seconds offset\n    // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n    return offset > 0 ? Math.floor(offset) : Math.ceil(offset);\n  }\n\n  //#endregion\n\n  //#region time\n\n  setTime(time) {\n    Date.prototype.setTime.apply(this, arguments);\n    syncToInternal(this);\n    return +this;\n  }\n\n  //#endregion\n\n  //#region date-fns integration\n\n  [Symbol.for(\"constructDateFrom\")](date) {\n    return new TZDateMini(+new Date(date), this.timeZone);\n  }\n\n  //#endregion\n}\n\n// Assign getters and setters\nconst re = /^(get|set)(?!UTC)/;\nObject.getOwnPropertyNames(Date.prototype).forEach(method => {\n  if (!re.test(method)) return;\n  const utcMethod = method.replace(re, \"$1UTC\");\n  // Filter out methods without UTC counterparts\n  if (!TZDateMini.prototype[utcMethod]) return;\n  if (method.startsWith(\"get\")) {\n    // Delegate to internal date's UTC method\n    TZDateMini.prototype[method] = function () {\n      return this.internal[utcMethod]();\n    };\n  } else {\n    // Assign regular setter\n    TZDateMini.prototype[method] = function () {\n      Date.prototype[utcMethod].apply(this.internal, arguments);\n      syncFromInternal(this);\n      return +this;\n    };\n\n    // Assign UTC setter\n    TZDateMini.prototype[utcMethod] = function () {\n      Date.prototype[utcMethod].apply(this, arguments);\n      syncToInternal(this);\n      return +this;\n    };\n  }\n});\n\n/**\n * Function syncs time to internal date, applying the time zone offset.\n *\n * @param {Date} date - Date to sync\n */\nfunction syncToInternal(date) {\n  date.internal.setTime(+date);\n  date.internal.setUTCSeconds(date.internal.getUTCSeconds() - Math.round(-tzOffset(date.timeZone, date) * 60));\n}\n\n/**\n * Function syncs the internal date UTC values to the date. It allows to get\n * accurate timestamp value.\n *\n * @param {Date} date - The date to sync\n */\nfunction syncFromInternal(date) {\n  // First we transpose the internal values\n  Date.prototype.setFullYear.call(date, date.internal.getUTCFullYear(), date.internal.getUTCMonth(), date.internal.getUTCDate());\n  Date.prototype.setHours.call(date, date.internal.getUTCHours(), date.internal.getUTCMinutes(), date.internal.getUTCSeconds(), date.internal.getUTCMilliseconds());\n\n  // Now we have to adjust the date to the system time zone\n  adjustToSystemTZ(date);\n}\n\n/**\n * Function adjusts the date to the system time zone. It uses the time zone\n * differences to calculate the offset and adjust the date.\n *\n * @param {Date} date - Date to adjust\n */\nfunction adjustToSystemTZ(date) {\n  // Save the time zone offset before all the adjustments\n  const baseOffset = tzOffset(date.timeZone, date);\n  // Remove the seconds offset\n  // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n  const offset = baseOffset > 0 ? Math.floor(baseOffset) : Math.ceil(baseOffset);\n  //#region System DST adjustment\n\n  // The biggest problem with using the system time zone is that when we create\n  // a date from internal values stored in UTC, the system time zone might end\n  // up on the DST hour:\n  //\n  //   $ TZ=America/New_York node\n  //   > new Date(2020, 2, 8, 1).toString()\n  //   'Sun Mar 08 2020 01:00:00 GMT-0500 (Eastern Standard Time)'\n  //   > new Date(2020, 2, 8, 2).toString()\n  //   'Sun Mar 08 2020 03:00:00 GMT-0400 (Eastern Daylight Time)'\n  //   > new Date(2020, 2, 8, 3).toString()\n  //   'Sun Mar 08 2020 03:00:00 GMT-0400 (Eastern Daylight Time)'\n  //   > new Date(2020, 2, 8, 4).toString()\n  //   'Sun Mar 08 2020 04:00:00 GMT-0400 (Eastern Daylight Time)'\n  //\n  // Here we get the same hour for both 2 and 3, because the system time zone\n  // has DST beginning at 8 March 2020, 2 a.m. and jumps to 3 a.m. So we have\n  // to adjust the internal date to reflect that.\n  //\n  // However we want to adjust only if that's the DST hour the change happenes,\n  // not the hour where DST moves to.\n\n  // We calculate the previous hour to see if the time zone offset has changed\n  // and we have landed on the DST hour.\n  const prevHour = new Date(+date);\n  // We use UTC methods here as we don't want to land on the same hour again\n  // in case of DST.\n  prevHour.setUTCHours(prevHour.getUTCHours() - 1);\n\n  // Calculate if we are on the system DST hour.\n  const systemOffset = -new Date(+date).getTimezoneOffset();\n  const prevHourSystemOffset = -new Date(+prevHour).getTimezoneOffset();\n  const systemDSTChange = systemOffset - prevHourSystemOffset;\n  // Detect the DST shift. System DST change will occur both on\n  const dstShift = Date.prototype.getHours.apply(date) !== date.internal.getUTCHours();\n\n  // Move the internal date when we are on the system DST hour.\n  if (systemDSTChange && dstShift) date.internal.setUTCMinutes(date.internal.getUTCMinutes() + systemDSTChange);\n\n  //#endregion\n\n  //#region System diff adjustment\n\n  // Now we need to adjust the date, since we just applied internal values.\n  // We need to calculate the difference between the system and date time zones\n  // and apply it to the date.\n\n  const offsetDiff = systemOffset - offset;\n  if (offsetDiff) Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetDiff);\n\n  //#endregion\n\n  //#region Seconds System diff adjustment\n\n  const systemDate = new Date(+date);\n  // Set the UTC seconds to 0 to isolate the timezone offset in seconds.\n  systemDate.setUTCSeconds(0);\n  // For negative systemOffset, invert the seconds.\n  const systemSecondsOffset = systemOffset > 0 ? systemDate.getSeconds() : (systemDate.getSeconds() - 60) % 60;\n\n  // Calculate the seconds offset based on the timezone offset.\n  const secondsOffset = Math.round(-(tzOffset(date.timeZone, date) * 60)) % 60;\n  if (secondsOffset || systemSecondsOffset) {\n    date.internal.setUTCSeconds(date.internal.getUTCSeconds() + secondsOffset);\n    Date.prototype.setUTCSeconds.call(date, Date.prototype.getUTCSeconds.call(date) + secondsOffset + systemSecondsOffset);\n  }\n\n  //#endregion\n\n  //#region Post-adjustment DST fix\n\n  const postBaseOffset = tzOffset(date.timeZone, date);\n  // Remove the seconds offset\n  // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n  const postOffset = postBaseOffset > 0 ? Math.floor(postBaseOffset) : Math.ceil(postBaseOffset);\n  const postSystemOffset = -new Date(+date).getTimezoneOffset();\n  const postOffsetDiff = postSystemOffset - postOffset;\n  const offsetChanged = postOffset !== offset;\n  const postDiff = postOffsetDiff - offsetDiff;\n  if (offsetChanged && postDiff) {\n    Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + postDiff);\n\n    // Now we need to check if got offset change during the post-adjustment.\n    // If so, we also need both dates to reflect that.\n\n    const newBaseOffset = tzOffset(date.timeZone, date);\n    // Remove the seconds offset\n    // use Math.floor for negative GMT timezones and Math.ceil for positive GMT timezones.\n    const newOffset = newBaseOffset > 0 ? Math.floor(newBaseOffset) : Math.ceil(newBaseOffset);\n    const offsetChange = postOffset - newOffset;\n    if (offsetChange) {\n      date.internal.setUTCMinutes(date.internal.getUTCMinutes() + offsetChange);\n      Date.prototype.setUTCMinutes.call(date, Date.prototype.getUTCMinutes.call(date) + offsetChange);\n    }\n  }\n\n  //#endregion\n}"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,sBAAsB;AAC/C,OAAO,MAAMC,UAAU,SAASC,IAAI,CAAC;EACnC;;EAEAC,WAAWA,CAAA,EAAU;IACnB,KAAK,CAAC,CAAC;IAAC,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EADKC,IAAI,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;MAAJF,IAAI,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;IAAA;IAEjB,IAAIF,IAAI,CAACD,MAAM,GAAG,CAAC,IAAI,OAAOC,IAAI,CAACA,IAAI,CAACD,MAAM,GAAG,CAAC,CAAC,KAAK,QAAQ,EAAE;MAChE,IAAI,CAACI,QAAQ,GAAGH,IAAI,CAACI,GAAG,CAAC,CAAC;IAC5B;IACA,IAAI,CAACC,QAAQ,GAAG,IAAIV,IAAI,CAAC,CAAC;IAC1B,IAAIW,KAAK,CAACb,QAAQ,CAAC,IAAI,CAACU,QAAQ,EAAE,IAAI,CAAC,CAAC,EAAE;MACxC,IAAI,CAACI,OAAO,CAACC,GAAG,CAAC;IACnB,CAAC,MAAM;MACL,IAAI,CAACR,IAAI,CAACD,MAAM,EAAE;QAChB,IAAI,CAACQ,OAAO,CAACZ,IAAI,CAACc,GAAG,CAAC,CAAC,CAAC;MAC1B,CAAC,MAAM,IAAI,OAAOT,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,KAAKA,IAAI,CAACD,MAAM,KAAK,CAAC,IAAIC,IAAI,CAACD,MAAM,KAAK,CAAC,IAAI,OAAOC,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,CAAC,EAAE;QACjH,IAAI,CAACO,OAAO,CAACP,IAAI,CAAC,CAAC,CAAC,CAAC;MACvB,CAAC,MAAM,IAAI,OAAOA,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;QACtC,IAAI,CAACO,OAAO,CAAC,CAAC,IAAIZ,IAAI,CAACK,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;MAClC,CAAC,MAAM,IAAIA,IAAI,CAAC,CAAC,CAAC,YAAYL,IAAI,EAAE;QAClC,IAAI,CAACY,OAAO,CAAC,CAACP,IAAI,CAAC,CAAC,CAAC,CAAC;MACxB,CAAC,MAAM;QACL,IAAI,CAACO,OAAO,CAAC,CAAC,IAAIZ,IAAI,CAAC,GAAGK,IAAI,CAAC,CAAC;QAChCU,gBAAgB,CAAC,IAAI,EAAEF,GAAG,CAAC;QAC3BG,cAAc,CAAC,IAAI,CAAC;MACtB;IACF;EACF;EACA,OAAOC,EAAEA,CAACA,EAAE,EAAW;IAAA,SAAAC,KAAA,GAAAf,SAAA,CAAAC,MAAA,EAANC,IAAI,OAAAC,KAAA,CAAAY,KAAA,OAAAA,KAAA,WAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAJd,IAAI,CAAAc,KAAA,QAAAhB,SAAA,CAAAgB,KAAA;IAAA;IACnB,OAAOd,IAAI,CAACD,MAAM,GAAG,IAAIL,UAAU,CAAC,GAAGM,IAAI,EAAEY,EAAE,CAAC,GAAG,IAAIlB,UAAU,CAACC,IAAI,CAACc,GAAG,CAAC,CAAC,EAAEG,EAAE,CAAC;EACnF;;EAEA;;EAEA;;EAEAG,YAAYA,CAACZ,QAAQ,EAAE;IACrB,OAAO,IAAIT,UAAU,CAAC,CAAC,IAAI,EAAES,QAAQ,CAAC;EACxC;EACAa,iBAAiBA,CAAA,EAAG;IAClB,MAAMC,MAAM,GAAG,CAACxB,QAAQ,CAAC,IAAI,CAACU,QAAQ,EAAE,IAAI,CAAC;IAC7C;IACA;IACA,OAAOc,MAAM,GAAG,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACF,MAAM,CAAC,GAAGC,IAAI,CAACE,IAAI,CAACH,MAAM,CAAC;EAC5D;;EAEA;;EAEA;;EAEAV,OAAOA,CAACc,IAAI,EAAE;IACZ1B,IAAI,CAAC2B,SAAS,CAACf,OAAO,CAACgB,KAAK,CAAC,IAAI,EAAEzB,SAAS,CAAC;IAC7Ca,cAAc,CAAC,IAAI,CAAC;IACpB,OAAO,CAAC,IAAI;EACd;;EAEA;;EAEA;;EAEA,CAACa,MAAM,CAACC,GAAG,CAAC,mBAAmB,CAAC,EAAEC,IAAI,EAAE;IACtC,OAAO,IAAIhC,UAAU,CAAC,CAAC,IAAIC,IAAI,CAAC+B,IAAI,CAAC,EAAE,IAAI,CAACvB,QAAQ,CAAC;EACvD;;EAEA;AACF;;AAEA;AACA,MAAMwB,EAAE,GAAG,mBAAmB;AAC9BC,MAAM,CAACC,mBAAmB,CAAClC,IAAI,CAAC2B,SAAS,CAAC,CAACQ,OAAO,CAACC,MAAM,IAAI;EAC3D,IAAI,CAACJ,EAAE,CAACK,IAAI,CAACD,MAAM,CAAC,EAAE;EACtB,MAAME,SAAS,GAAGF,MAAM,CAACG,OAAO,CAACP,EAAE,EAAE,OAAO,CAAC;EAC7C;EACA,IAAI,CAACjC,UAAU,CAAC4B,SAAS,CAACW,SAAS,CAAC,EAAE;EACtC,IAAIF,MAAM,CAACI,UAAU,CAAC,KAAK,CAAC,EAAE;IAC5B;IACAzC,UAAU,CAAC4B,SAAS,CAACS,MAAM,CAAC,GAAG,YAAY;MACzC,OAAO,IAAI,CAAC1B,QAAQ,CAAC4B,SAAS,CAAC,CAAC,CAAC;IACnC,CAAC;EACH,CAAC,MAAM;IACL;IACAvC,UAAU,CAAC4B,SAAS,CAACS,MAAM,CAAC,GAAG,YAAY;MACzCpC,IAAI,CAAC2B,SAAS,CAACW,SAAS,CAAC,CAACV,KAAK,CAAC,IAAI,CAAClB,QAAQ,EAAEP,SAAS,CAAC;MACzDsC,gBAAgB,CAAC,IAAI,CAAC;MACtB,OAAO,CAAC,IAAI;IACd,CAAC;;IAED;IACA1C,UAAU,CAAC4B,SAAS,CAACW,SAAS,CAAC,GAAG,YAAY;MAC5CtC,IAAI,CAAC2B,SAAS,CAACW,SAAS,CAAC,CAACV,KAAK,CAAC,IAAI,EAAEzB,SAAS,CAAC;MAChDa,cAAc,CAAC,IAAI,CAAC;MACpB,OAAO,CAAC,IAAI;IACd,CAAC;EACH;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA,SAASA,cAAcA,CAACe,IAAI,EAAE;EAC5BA,IAAI,CAACrB,QAAQ,CAACE,OAAO,CAAC,CAACmB,IAAI,CAAC;EAC5BA,IAAI,CAACrB,QAAQ,CAACgC,aAAa,CAACX,IAAI,CAACrB,QAAQ,CAACiC,aAAa,CAAC,CAAC,GAAGpB,IAAI,CAACqB,KAAK,CAAC,CAAC9C,QAAQ,CAACiC,IAAI,CAACvB,QAAQ,EAAEuB,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC;AAC9G;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASU,gBAAgBA,CAACV,IAAI,EAAE;EAC9B;EACA/B,IAAI,CAAC2B,SAAS,CAACkB,WAAW,CAACC,IAAI,CAACf,IAAI,EAAEA,IAAI,CAACrB,QAAQ,CAACqC,cAAc,CAAC,CAAC,EAAEhB,IAAI,CAACrB,QAAQ,CAACsC,WAAW,CAAC,CAAC,EAAEjB,IAAI,CAACrB,QAAQ,CAACuC,UAAU,CAAC,CAAC,CAAC;EAC9HjD,IAAI,CAAC2B,SAAS,CAACuB,QAAQ,CAACJ,IAAI,CAACf,IAAI,EAAEA,IAAI,CAACrB,QAAQ,CAACyC,WAAW,CAAC,CAAC,EAAEpB,IAAI,CAACrB,QAAQ,CAAC0C,aAAa,CAAC,CAAC,EAAErB,IAAI,CAACrB,QAAQ,CAACiC,aAAa,CAAC,CAAC,EAAEZ,IAAI,CAACrB,QAAQ,CAAC2C,kBAAkB,CAAC,CAAC,CAAC;;EAEjK;EACAtC,gBAAgB,CAACgB,IAAI,CAAC;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAShB,gBAAgBA,CAACgB,IAAI,EAAE;EAC9B;EACA,MAAMuB,UAAU,GAAGxD,QAAQ,CAACiC,IAAI,CAACvB,QAAQ,EAAEuB,IAAI,CAAC;EAChD;EACA;EACA,MAAMT,MAAM,GAAGgC,UAAU,GAAG,CAAC,GAAG/B,IAAI,CAACC,KAAK,CAAC8B,UAAU,CAAC,GAAG/B,IAAI,CAACE,IAAI,CAAC6B,UAAU,CAAC;EAC9E;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA,MAAMC,QAAQ,GAAG,IAAIvD,IAAI,CAAC,CAAC+B,IAAI,CAAC;EAChC;EACA;EACAwB,QAAQ,CAACC,WAAW,CAACD,QAAQ,CAACJ,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC;;EAEhD;EACA,MAAMM,YAAY,GAAG,CAAC,IAAIzD,IAAI,CAAC,CAAC+B,IAAI,CAAC,CAACV,iBAAiB,CAAC,CAAC;EACzD,MAAMqC,oBAAoB,GAAG,CAAC,IAAI1D,IAAI,CAAC,CAACuD,QAAQ,CAAC,CAAClC,iBAAiB,CAAC,CAAC;EACrE,MAAMsC,eAAe,GAAGF,YAAY,GAAGC,oBAAoB;EAC3D;EACA,MAAME,QAAQ,GAAG5D,IAAI,CAAC2B,SAAS,CAACkC,QAAQ,CAACjC,KAAK,CAACG,IAAI,CAAC,KAAKA,IAAI,CAACrB,QAAQ,CAACyC,WAAW,CAAC,CAAC;;EAEpF;EACA,IAAIQ,eAAe,IAAIC,QAAQ,EAAE7B,IAAI,CAACrB,QAAQ,CAACoD,aAAa,CAAC/B,IAAI,CAACrB,QAAQ,CAAC0C,aAAa,CAAC,CAAC,GAAGO,eAAe,CAAC;;EAE7G;;EAEA;;EAEA;EACA;EACA;;EAEA,MAAMI,UAAU,GAAGN,YAAY,GAAGnC,MAAM;EACxC,IAAIyC,UAAU,EAAE/D,IAAI,CAAC2B,SAAS,CAACmC,aAAa,CAAChB,IAAI,CAACf,IAAI,EAAE/B,IAAI,CAAC2B,SAAS,CAACyB,aAAa,CAACN,IAAI,CAACf,IAAI,CAAC,GAAGgC,UAAU,CAAC;;EAE7G;;EAEA;;EAEA,MAAMC,UAAU,GAAG,IAAIhE,IAAI,CAAC,CAAC+B,IAAI,CAAC;EAClC;EACAiC,UAAU,CAACtB,aAAa,CAAC,CAAC,CAAC;EAC3B;EACA,MAAMuB,mBAAmB,GAAGR,YAAY,GAAG,CAAC,GAAGO,UAAU,CAACE,UAAU,CAAC,CAAC,GAAG,CAACF,UAAU,CAACE,UAAU,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE;;EAE5G;EACA,MAAMC,aAAa,GAAG5C,IAAI,CAACqB,KAAK,CAAC,EAAE9C,QAAQ,CAACiC,IAAI,CAACvB,QAAQ,EAAEuB,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE;EAC5E,IAAIoC,aAAa,IAAIF,mBAAmB,EAAE;IACxClC,IAAI,CAACrB,QAAQ,CAACgC,aAAa,CAACX,IAAI,CAACrB,QAAQ,CAACiC,aAAa,CAAC,CAAC,GAAGwB,aAAa,CAAC;IAC1EnE,IAAI,CAAC2B,SAAS,CAACe,aAAa,CAACI,IAAI,CAACf,IAAI,EAAE/B,IAAI,CAAC2B,SAAS,CAACgB,aAAa,CAACG,IAAI,CAACf,IAAI,CAAC,GAAGoC,aAAa,GAAGF,mBAAmB,CAAC;EACxH;;EAEA;;EAEA;;EAEA,MAAMG,cAAc,GAAGtE,QAAQ,CAACiC,IAAI,CAACvB,QAAQ,EAAEuB,IAAI,CAAC;EACpD;EACA;EACA,MAAMsC,UAAU,GAAGD,cAAc,GAAG,CAAC,GAAG7C,IAAI,CAACC,KAAK,CAAC4C,cAAc,CAAC,GAAG7C,IAAI,CAACE,IAAI,CAAC2C,cAAc,CAAC;EAC9F,MAAME,gBAAgB,GAAG,CAAC,IAAItE,IAAI,CAAC,CAAC+B,IAAI,CAAC,CAACV,iBAAiB,CAAC,CAAC;EAC7D,MAAMkD,cAAc,GAAGD,gBAAgB,GAAGD,UAAU;EACpD,MAAMG,aAAa,GAAGH,UAAU,KAAK/C,MAAM;EAC3C,MAAMmD,QAAQ,GAAGF,cAAc,GAAGR,UAAU;EAC5C,IAAIS,aAAa,IAAIC,QAAQ,EAAE;IAC7BzE,IAAI,CAAC2B,SAAS,CAACmC,aAAa,CAAChB,IAAI,CAACf,IAAI,EAAE/B,IAAI,CAAC2B,SAAS,CAACyB,aAAa,CAACN,IAAI,CAACf,IAAI,CAAC,GAAG0C,QAAQ,CAAC;;IAE3F;IACA;;IAEA,MAAMC,aAAa,GAAG5E,QAAQ,CAACiC,IAAI,CAACvB,QAAQ,EAAEuB,IAAI,CAAC;IACnD;IACA;IACA,MAAM4C,SAAS,GAAGD,aAAa,GAAG,CAAC,GAAGnD,IAAI,CAACC,KAAK,CAACkD,aAAa,CAAC,GAAGnD,IAAI,CAACE,IAAI,CAACiD,aAAa,CAAC;IAC1F,MAAME,YAAY,GAAGP,UAAU,GAAGM,SAAS;IAC3C,IAAIC,YAAY,EAAE;MAChB7C,IAAI,CAACrB,QAAQ,CAACoD,aAAa,CAAC/B,IAAI,CAACrB,QAAQ,CAAC0C,aAAa,CAAC,CAAC,GAAGwB,YAAY,CAAC;MACzE5E,IAAI,CAAC2B,SAAS,CAACmC,aAAa,CAAChB,IAAI,CAACf,IAAI,EAAE/B,IAAI,CAAC2B,SAAS,CAACyB,aAAa,CAACN,IAAI,CAACf,IAAI,CAAC,GAAG6C,YAAY,CAAC;IACjG;EACF;;EAEA;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}